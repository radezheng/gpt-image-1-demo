#!/usr/bin/env python3
"""
Flask web app for interactive image generation using Azure OpenAI Image API.
Requires AZURE_OPENAI_ENDPOINT and AZURE_OPENAI_KEY environment variables.
"""
from flask import Flask, request, render_template, jsonify
from flask_cors import CORS
from dotenv import load_dotenv
import os
import requests
import base64
import time
from io import BytesIO

load_dotenv()

app = Flask(__name__, static_folder='img', static_url_path='/img')
CORS(app, resources={r"/*": {"origins": "http://localhost:3000"}})

# Parameters
MODELS = ["gpt-image-1"]
SIZES = ["1024x1024", "1024x1536", "1536x1024"]
QUALITIES = ["low", "medium", "high"]


def validate_resp_schema(data):
    """Validate Azure Image API response structure"""
    if not isinstance(data, dict):
        return False
    # required top-level keys
    required = ["created", "data", "usage"]
    if not all(k in data for k in required):
        return False
    if not isinstance(data["created"], int):
        return False
    if not isinstance(data["data"], list):
        return False
    for item in data["data"]:
        if not isinstance(item, dict):
            return False
        if not ("url" in item or "b64_json" in item):
            return False
    usage = data.get("usage")
    if not isinstance(usage, dict):
        return False
    # check usage fields
    u_keys = ["input_tokens", "input_tokens_details", "output_tokens", "total_tokens"]
    if not all(k in usage for k in u_keys):
        return False
    if not isinstance(usage["input_tokens"], int) or not isinstance(usage["output_tokens"], int) or not isinstance(usage["total_tokens"], int):
        return False
    det = usage.get("input_tokens_details")
    if not isinstance(det, dict):
        return False
    if not (isinstance(det.get("image_tokens"), int) and isinstance(det.get("text_tokens"), int)):
        return False
    return True


def call_image_api(prompt, model, size, n, quality):
    endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
    key = os.getenv("AZURE_OPENAI_KEY")
    if not endpoint or not key:
        raise RuntimeError("Please set AZURE_OPENAI_ENDPOINT and AZURE_OPENAI_KEY environment variables.")
    url = f"{endpoint}/openai/deployments/{model}/images/generations?api-version=2025-03-01-preview"
    headers = {"Content-Type": "application/json", "api-key": key}
    payload = {"prompt": prompt, "model": model, "size": size, "n": n, "quality": quality}
    # add timeout to avoid hanging indefinitely
    resp = requests.post(url, headers=headers, json=payload, timeout=200)
    if resp.status_code != 200:
        print(f"API call error: {resp.status_code} {resp.text}")
    resp.raise_for_status()
    data = resp.json()
    if not validate_resp_schema(data):
        raise ValueError("Invalid API response format")
    os.makedirs('img', exist_ok=True)
    urls = []
    ts = int(time.time())
    for i, item in enumerate(data.get("data", [])):
        # get image bytes
        if "url" in item:
            resp2 = requests.get(item["url"], timeout=60)
            resp2.raise_for_status()
            img_bytes = resp2.content
        else:
            img_bytes = base64.b64decode(item["b64_json"])
        # write file
        fname = f"image_{ts}_{i}.png"
        path = os.path.join('img', fname)
        with open(path, 'wb') as f:
            f.write(img_bytes)
        urls.append(f"/img/{fname}")
    # include usage from API response
    usage = data.get('usage')
    return {'urls': urls, 'usage': usage}


def call_image_edit_api(base64_image, prompt, model, size, n, quality):
    endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
    key = os.getenv("AZURE_OPENAI_KEY")
    if not endpoint or not key:
        raise RuntimeError("Please set AZURE_OPENAI_ENDPOINT and AZURE_OPENAI_KEY environment variables.")
    url = f"{endpoint}/openai/deployments/{model}/images/edits?api-version=2025-04-01-preview"
    # decode Base64 image to bytes
    image_bytes = base64.b64decode(base64_image)
    file_obj = BytesIO(image_bytes)
    file_obj.name = 'image.png'
    # use supported image mime type based on file extension
    files = {'image': (file_obj.name, file_obj, 'image/png')}
    data = {"prompt": prompt, "model": model, "size": size, "n": n, "quality": quality}
    # multipart/form-data auto generated by requests
    resp = requests.post(url, headers={"api-key": key}, files=files, data=data, timeout=200)
    #don't remove this line
    if resp.status_code != 200:
        print(f"API call error: {resp.status_code} {resp.text}")
    resp.raise_for_status()
    data_json = resp.json()
    if not validate_resp_schema(data_json):
        raise ValueError("Invalid API response format for image edit")
    os.makedirs('img', exist_ok=True)
    urls = []
    ts = int(time.time())
    for i, item in enumerate(data_json.get("data", [])):
        if "url" in item:
            resp2 = requests.get(item["url"], timeout=60)
            resp2.raise_for_status()
            img_bytes = resp2.content
        else:
            img_bytes = base64.b64decode(item["b64_json"])
        fname = f"edit_{ts}_{i}.png"
        path = os.path.join('img', fname)
        with open(path, 'wb') as f:
            f.write(img_bytes)
        urls.append(f"/img/{fname}")
    # include usage from API response
    usage = data_json.get('usage')
    return {'urls': urls, 'usage': usage}


@app.route('/', methods=['GET'])
def index():
    return render_template('index.html', models=MODELS, sizes=SIZES, qualities=QUALITIES)


@app.route('/generate', methods=['POST'])
def generate():
    try:
        # support JSON requests from React front-end
        if request.is_json:
            data = request.get_json()
            prompt = data.get('prompt')
            model = data.get('model')
            size = data.get('size')
            n = int(data.get('n', 1))
            quality = data.get('quality')
            result = call_image_api(prompt, model, size, n, quality)
            return jsonify(result), 200
        # fallback to form submission
        prompt = request.form['prompt']
        model = request.form['model']
        size = request.form['size']
        n = int(request.form.get('n', 1))
        quality = request.form['quality']
        result = call_image_api(prompt, model, size, n, quality)
        urls = result['urls']
    # catch specific exceptions for request failures and validation errors
    except (requests.exceptions.RequestException, ValueError) as e:
        print(f"Error: {e}")
        if request.is_json:
            return jsonify({'error': str(e)}), 400
        return f"Error: {e}", 400
    return render_template('result.html', urls=urls)


@app.route('/edit', methods=['POST'])
def edit():
    try:
        if not request.is_json:
            return jsonify({'error': 'JSON body required'}), 400
        data = request.get_json()
        base64_img = data.get('image')
        if not base64_img:
            return jsonify({'error': 'No image provided'}), 400
        prompt = data.get('prompt')
        model = data.get('model')
        size = data.get('size')
        n = int(data.get('n', 1))
        quality = data.get('quality')
        result = call_image_edit_api(base64_img, prompt, model, size, n, quality)
        return jsonify(result), 200
    except (requests.exceptions.RequestException, ValueError) as e:
        print(f"Error: {e}")
        return jsonify({'error': str(e)}), 400


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5005, debug=True)
